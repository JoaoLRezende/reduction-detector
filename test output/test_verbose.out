Likely reduction loop at /home/jplrez/Desktop/pesquisa/reduction-detector/test cases/reduction loops/NPB 4.c:26:4:
for (nOnes = 0 , i = 0; i < 64; i++) {
    if (s & ob)
        nOnes++;
    ob >>= 1;
}
I couldn't determine its iteration variable.
Likely accumulators: ob

    ob was detected as a likely accumulator (score: 7). It is not a trivial accumulator.
    Its base is ob, which was declared 4 lines above the loop.
    Its name doesn't have any of the common accumulator-name substrings.
    It might be accumulated in the following assignments:
        ob >>= 1
    0 of those assignments involve the loop's iteration variable.
    There are 1 other in-loop references to ob outside of those possible accumulating assignments.

Likely reduction loop at /home/jplrez/Desktop/pesquisa/reduction-detector/test cases/reduction loops/NPB 3.c:65:5:
for (iib = 1; iib <= nsgs; iib++) {
    if (iib > 1)
        fseek(avp->viewFile, inpfOffset, 0);
    ;
    if (iib == nsgs)
        ncur = nlst;
    else
        ncur = nreg;
    fread(ib, ncur * avp->inpRecSize, 1, avp->viewFile);
    inpfOffset = ftell(avp->viewFile);
    for (ibOffset = 0 , iRec = 1; iRec <= ncur; iRec++) {
        memcpy(attrs, &ib[ibOffset], avp->inpRecSize);
        ibOffset += avp->inpRecSize;
        SelectToView(attrs, avp->selection, currBuf, avp->nd, avp->nm, avp->nv);
        currV = currBuf[2 * avp->nm];
        if (iib == 1 && iRec == 1) {
            prevV = currV;
            nPart = 1;
            InitializeTree(avp->tree, avp->nv, avp->nm);
            TreeInsert(avp->tree, currBuf);
        } else {
            if (currV == prevV) {
                nPart++;
                TreeInsert(avp->tree, currBuf);
                if (avp->tree->memoryIsFull) {
                    avp->chunksParams[avp->numberOfChunks].curChunkNum = avp->tree->count;
                    avp->chunksParams[avp->numberOfChunks].chunkOffset = chunkOffset;
                    (avp->numberOfChunks)++;
                    if (avp->numberOfChunks >= 1024) {
                        fprintf(stderr, "Too many chunks were created.\n");
                        exit(1);
                    }
                    chunkOffset += (uint64)(avp->tree->count * avp->outRecSize);
                    retCode = WriteChunkToDisk(avp->outRecSize, avp->fileOfChunks, avp->tree->root.left, avp->logf);
                    if (retCode != 0) {
                        fprintf(stderr, "SharedSortAggregate: Write error occured.\n");
                        return retCode;
                    }
                    InitializeTree(avp->tree, avp->nv, avp->nm);
                }
            } else {
                if (avp->numberOfChunks && avp->tree->count != 0) {
                    avp->chunksParams[avp->numberOfChunks].curChunkNum = avp->tree->count;
                    avp->chunksParams[avp->numberOfChunks].chunkOffset = chunkOffset;
                    (avp->numberOfChunks)++;
                    chunkOffset += (uint64)(avp->tree->count * (4 * avp->nv + 8 * avp->nm));
                    retCode = WriteChunkToDisk(avp->outRecSize, avp->fileOfChunks, avp->tree->root.left, avp->logf);
                    if (retCode != 0) {
                        fprintf(stderr, "SharedSortAggregate: Write error occured.\n");
                        return retCode;
                    }
                }
                fseek(avp->viewFile, 0L, 2);
                ;
                if (!avp->numberOfChunks) {
                    avp->nViewRows += avp->tree->count;
                    retCode = WriteViewToDiskCS(avp, avp->tree->root.left, &ordern);
                    if (retCode != 0) {
                        fprintf(stderr, "SharedSortAggregate: Write error occured.\n");
                        return retCode;
                    }
                } else {
                    retCode = MultiWayMerge(avp);
                    if (retCode != 0) {
                        fprintf(stderr, "SharedSortAggregate.MultiWayMerge: failed.\n");
                        return retCode;
                    }
                }
                InitializeTree(avp->tree, avp->nv, avp->nm);
                TreeInsert(avp->tree, currBuf);
                total += nPart;
                nPart = 1;
            }
        }
        prevV = currV;
    }
}
Its iteration variable is iib.
No arrays are subscripted by iib..
Likely accumulators: total avp->nViewRows

    total was detected as a likely accumulator (score: 13). But it is a trivial accumulator.
    Its base is total, which was declared 5 lines above the loop.
    Its name has the substring "total".
    It might be accumulated in the following assignments:
        total += nPart
    0 of those assignments involve the loop's iteration variable.
    There are 0 other in-loop references to total outside of those possible accumulating assignments.

    avp->nViewRows was detected as a likely accumulator (score: 8). It is not a trivial accumulator.
    Its base is avp, which was declared 29 lines above the loop.
    Its name doesn't have any of the common accumulator-name substrings.
    It might be accumulated in the following assignments:
        avp->nViewRows += avp->tree->count
    0 of those assignments involve the loop's iteration variable.
    There are 0 other in-loop references to avp->nViewRows outside of those possible accumulating assignments.

Likely reduction loop at /home/jplrez/Desktop/pesquisa/reduction-detector/test cases/reduction loops/NPB 3.c:75:9:
for (ibOffset = 0 , iRec = 1; iRec <= ncur; iRec++) {
    memcpy(attrs, &ib[ibOffset], avp->inpRecSize);
    ibOffset += avp->inpRecSize;
    SelectToView(attrs, avp->selection, currBuf, avp->nd, avp->nm, avp->nv);
    currV = currBuf[2 * avp->nm];
    if (iib == 1 && iRec == 1) {
        prevV = currV;
        nPart = 1;
        InitializeTree(avp->tree, avp->nv, avp->nm);
        TreeInsert(avp->tree, currBuf);
    } else {
        if (currV == prevV) {
            nPart++;
            TreeInsert(avp->tree, currBuf);
            if (avp->tree->memoryIsFull) {
                avp->chunksParams[avp->numberOfChunks].curChunkNum = avp->tree->count;
                avp->chunksParams[avp->numberOfChunks].chunkOffset = chunkOffset;
                (avp->numberOfChunks)++;
                if (avp->numberOfChunks >= 1024) {
                    fprintf(stderr, "Too many chunks were created.\n");
                    exit(1);
                }
                chunkOffset += (uint64)(avp->tree->count * avp->outRecSize);
                retCode = WriteChunkToDisk(avp->outRecSize, avp->fileOfChunks, avp->tree->root.left, avp->logf);
                if (retCode != 0) {
                    fprintf(stderr, "SharedSortAggregate: Write error occured.\n");
                    return retCode;
                }
                InitializeTree(avp->tree, avp->nv, avp->nm);
            }
        } else {
            if (avp->numberOfChunks && avp->tree->count != 0) {
                avp->chunksParams[avp->numberOfChunks].curChunkNum = avp->tree->count;
                avp->chunksParams[avp->numberOfChunks].chunkOffset = chunkOffset;
                (avp->numberOfChunks)++;
                chunkOffset += (uint64)(avp->tree->count * (4 * avp->nv + 8 * avp->nm));
                retCode = WriteChunkToDisk(avp->outRecSize, avp->fileOfChunks, avp->tree->root.left, avp->logf);
                if (retCode != 0) {
                    fprintf(stderr, "SharedSortAggregate: Write error occured.\n");
                    return retCode;
                }
            }
            fseek(avp->viewFile, 0L, 2);
            ;
            if (!avp->numberOfChunks) {
                avp->nViewRows += avp->tree->count;
                retCode = WriteViewToDiskCS(avp, avp->tree->root.left, &ordern);
                if (retCode != 0) {
                    fprintf(stderr, "SharedSortAggregate: Write error occured.\n");
                    return retCode;
                }
            } else {
                retCode = MultiWayMerge(avp);
                if (retCode != 0) {
                    fprintf(stderr, "SharedSortAggregate.MultiWayMerge: failed.\n");
                    return retCode;
                }
            }
            InitializeTree(avp->tree, avp->nv, avp->nm);
            TreeInsert(avp->tree, currBuf);
            total += nPart;
            nPart = 1;
        }
    }
    prevV = currV;
}
I couldn't determine its iteration variable.
Likely accumulators: total avp->nViewRows

    total was detected as a likely accumulator (score: 13). But it is a trivial accumulator.
    Its base is total, which was declared 15 lines above the loop.
    Its name has the substring "total".
    It might be accumulated in the following assignments:
        total += nPart
    0 of those assignments involve the loop's iteration variable.
    There are 0 other in-loop references to total outside of those possible accumulating assignments.

    avp->nViewRows was detected as a likely accumulator (score: 8). It is not a trivial accumulator.
    Its base is avp, which was declared 39 lines above the loop.
    Its name doesn't have any of the common accumulator-name substrings.
    It might be accumulated in the following assignments:
        avp->nViewRows += avp->tree->count
    0 of those assignments involve the loop's iteration variable.
    There are 0 other in-loop references to avp->nViewRows outside of those possible accumulating assignments.

Likely reduction loop at /home/jplrez/Desktop/pesquisa/reduction-detector/test cases/reduction loops/artificial examples.c:27:3:
for (int i = 0; i < array_size; i++) {
    int old_sum = sum;
    old_sum += array[i];
    sum = old_sum;
}
Its iteration variable is i.
Arrays subscripted by i: array (1 accesses).
Likely accumulators: sum

    sum was detected as a likely accumulator (score: 11). It is not a trivial accumulator.
    Its base is sum, which was declared 1 lines above the loop.
    Its name has the substring "sum".
    It might be accumulated in the following assignments:
    0 of those assignments involve the loop's iteration variable.
    There are 1 other in-loop references to sum outside of those possible accumulating assignments.

Likely reduction loop at /home/jplrez/Desktop/pesquisa/reduction-detector/test cases/reduction loops/artificial examples.c:88:3:
for (size_t i = 0; i < array_size; i++) {
    *accumulator += array[i];
    printf("%d ", *accumulator);
}
Its iteration variable is i.
Arrays subscripted by i: array (1 accesses).
Likely accumulators: *accumulator

    *accumulator was detected as a likely accumulator (score: 14). It is not a trivial accumulator.
    Its base is accumulator, which was declared 1 lines above the loop.
    Its name has the substring "acc".
    It might be accumulated in the following assignments:
        *accumulator += array[i]
    1 of those assignments involve the loop's iteration variable.
    There are 1 other in-loop references to *accumulator outside of those possible accumulating assignments.

Likely reduction loop at /home/jplrez/Desktop/pesquisa/reduction-detector/test cases/reduction loops/artificial examples.c:95:3:
for (size_t i = 0; i < array_size; i++) {
    accumulators[0] += array[i];
    printf("%d ", accumulators[0]);
}
Its iteration variable is i.
Arrays subscripted by i: array (1 accesses).
Likely accumulators: accumulators[0]

    accumulators[0] was detected as a likely accumulator (score: 14). It is not a trivial accumulator.
    Its base is accumulators, which was declared 1 lines above the loop.
    Its name has the substring "acc".
    It might be accumulated in the following assignments:
        accumulators[0] += array[i]
    1 of those assignments involve the loop's iteration variable.
    There are 1 other in-loop references to accumulators[0] outside of those possible accumulating assignments.

Likely reduction loop at /home/jplrez/Desktop/pesquisa/reduction-detector/test cases/reduction loops/artificial examples.c:108:3:
for (size_t i = 0; i < size; ++i) {
    result->sum += array[i];
    printf("%d ", result->sum);
}
Its iteration variable is i.
Arrays subscripted by i: array (1 accesses).
Likely accumulators: result->sum

    result->sum was detected as a likely accumulator (score: 14). It is not a trivial accumulator.
    Its base is result, which was declared 2 lines above the loop.
    Its name has the substring "sum".
    It might be accumulated in the following assignments:
        result->sum += array[i]
    1 of those assignments involve the loop's iteration variable.
    There are 1 other in-loop references to result->sum outside of those possible accumulating assignments.

19 out of 21 loops detected as likely reduction loops. 14 of them are trivial reductions. (Trivial reductions not shown.)
    19 out of 21 for loops.
    0 out of 0 while loops.
    0 out of 0 do-while loops.
